
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Monocurl | Learn</title>

		<!-- Meta  -->
		<meta charset="UTF-8">
		<meta name="description" content="Monocurl is a desktop application used to create mathematically-defined slideshows and videos.">
		<meta name="keywords" content="Monocurl, math, animation, presentations, slideshows">
		<meta name="author" content="Manu Bhat">

		<link rel="icon" href="/img/monocurl_icon.png">

		<!-- CSS -->
		<link rel="stylesheet" href="/css/main.css">
		<link rel="stylesheet" href="/css/lessons.css">

		
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css">
            <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
        

		<!-- JS -->
		
            <script>
                hljs.highlightAll();

                function rescroll() {
                    var lastElement = -1
                    document.querySelectorAll("h2").forEach((h2, index) => {
                        const rect = h2.getBoundingClientRect()
                        document.getElementById(`label-${index}`).className = ""
                        if (rect.top < 400) {
                            lastElement = index
                        }
                    });
                    if (lastElement !== -1) {
                        document.getElementById(`label-${lastElement}`).className = "active"
                        lastElement.className = "active"
                    }
                }

                document.addEventListener('DOMContentLoaded', () => {
                    document.querySelectorAll("h2").forEach((h2, index) => {
                        h2.id = `section-${index}`;
                    });
                });

                document.onscroll = rescroll
            </script>
        
	</head>
    
	<!-- Main -->
	<body>
		<nav>
			<a id='monocurl-title' href="/"> Monocurl </a> 
			
			<div class="spacer"> </div>

			<a class="navlink active" href="/learn/0_What_is_Monocurl">           Learn    </a>
			<a class="navlink " href="/docs/%20camera">     Docs     </a>
			<a class="navlink " href="/examples">        Examples </a>
			<a class="navlink " href="/credits">         Credits  </a>
		</nav>

		<main>
    <aside><h1> Learn </h1><a href="0_What_is_Monocurl" class="">0 What is Monocurl</a><a href="1_Monocurl_Language" class="">1 Monocurl Language</a><a href="2_Using_the_Editor" class="">2 Using the Editor</a><a href="3_Meshes" class="">3 Meshes</a><a href="4_Animation_Basics" class="">4 Animation Basics</a><a href="5_Examples_of_Animations" class="current">5 Examples of Animations</a><a href="6_Iterator_Follower_Paradigm" class="">6 Iterator Follower Paradigm</a><a href="7_Interpolation_Animations" class="">7 Interpolation Animations</a><a href="8_Tagging_Mechanics" class="">8 Tagging Mechanics</a><a href="9_Tips_and_Advice" class="">9 Tips and Advice</a><a href="10_Future_Works" class="">10 Future Works</a></aside><div id="content"><h1>5. Examples of Animations</h1>
<p><span class="lesson-meta">META</span> Now that we have an idea of how animations are composed, we'll talk about some common examples.</p>
<h2>5.1 Visibility of Meshes</h2>
<p><span class="lesson-important">IMPORTANT</span> In order to actually show meshes on screen there are two steps. 1) Declaring the on-screen container to where meshes can be sent (e.g. <code class="language-swift">tree main</code>). 2) Actually sending the mesh to the container (e.g. <code class="language-swift">Show</code>).</p>
<p>Thus, we can declare <code class="language-swift">trees</code> as 'containers' for where our meshes are to be copied into. Once we dump a mesh into a tree using an animation, that mesh will be a visible member of the tree. Likewise, we can hide meshes from a tree, and then the mesh will no longer be visible. We can even modify the meshes in the tree with time, which provides the basis for cool animations.</p>
<p><span class="lesson-remark">REMARK</span> Do note you can have multiple trees in a scene, even though we've only had one in the previous ones. Trees somewhat provide a sense of ownership.</p>
<p><span class="lesson-remark">REMARK</span> I went through many such systems for visibility. It's a surprisingly hard task to come up with an elegant system that also respects copy-by-value semantics, but I think this is the best, even if it's somewhat verbose at times.</p>
<h2>5.2 Animation Syntax</h2>
<p>Animations are typically called as functors as well. Do note that they generally take a reference (denoted '&amp;'), which is the tree that you want to animate. Animations connect the variables that we compute with the on-screen components.</p>
<pre><code class="language-swift">tree shapes_container
tree square_container

let circle = Circle:
    center: ORIGIN
    radius: 1
    tag: {}
    color: default

/* copy the circle into the shapes container */
/* remember: as part of delayed execution this is just an instruction */
/* the actual showing does not take place until after initialization */
play += Show:
    into&amp;: shapes_container
    value: circle
    sticky: 0

let square = Square:
    center: ORIGIN
    width: 1
    tag: {}
    color: default

play += Wait(1, 0)

/* copy the square into the shapes container */
/* a container can hold many meshes */
play += Show:
    into&amp;: shapes_container
    value: square
    sticky: 0

play += Wait(1, 0)

/* technically, we can even copy a mesh into multiple containers */
/* this emphasizes the show operation as a copy, not a transfer */
play += Show:
    into&amp;: square_container
    value: square
    sticky: 0

play += Wait(1, 0)

/* if we now hide everything from the shapes_container */
/* only the square_container will have anything, so we just */
/* see the square */
play += Hide:
    from&amp;: shapes_container
    sticky: 0

/* Also, note that the following gives an error */
/* we have to animation on trees */
var not_a_tree = -1
play += Show:
    into&amp;: not_a_tree
    value: circle
    sticky: 0
</code></pre>
<h2>5.3 Show, Wait, and Hide</h2>
<p>Lets review our first few animations</p>
<p><span class="lesson-important">IMPORTANT</span> Show copies a mesh into a tree, which essentially makes a mesh visible. Wait does nothing for a time period. Hide removes the meshes from a tree, which makes them invisible.</p>
<p>Again, it's really important to notice that when we say <code class="language-swift">play += Show:</code> all we're doing is adding the instruction. The actual work happens after the slide initialization phase. </p>
<p>Here, we show a line, wait for one second, then hide it. Feel free to try it in the editor, and explore with more complicated meshes.</p>
<pre><code class="language-swift">tree main
let line = Line:
    start: ORIGIN
    end: {1,1,0}
    tag: {}
    stroke: RED

/* here we use wait so much that we might as well save it */
let wait = Wait:
    time: 1
    sticky: 0

play += wait

play += Show:
    into&amp;: main
    value: line
    sticky: 0
play += wait
play += Hide:
    from&amp;: main
    sticky: 0

play += wait
</code></pre>
<p>This is the result. Our first animation!</p>
<video controls>
    Line that shows, waits, hides 
    <source src="/video/line_swh.mp4" type="video/mp4"/>
</video>

<h2>5.4 More complex Show and Hide</h2>
<p>Now, we can finally understand a bit more about what was happening when we showed the meshes!</p>
<p>Show and Hide perform their operation instantly, but there are more elaborate ways to do the same. For example, we have <a href="/docs/FadeIn">FadeIn</a>, <a href="/docs/Write">Write</a>, and <a href="/docs/Grow">Grow</a>. For hiding, we similarly have <a href="/docs/FadeOut">FadeOut</a>, <a href="/docs/Unwrite">Unwrite</a>, and <a href="/docs/Shrink">Shrink</a>. Here's an example of how Write looks (the mesh is <a href="/docs/Tex">Tex</a>).</p>
<pre><code class="language-swift">tree main
var tex = Tex:
    tex: "\int_{-\infty}^{\infty}e^{-x^2}dx = \sqrt{\pi}"
    scale: 1
    stroke: CLEAR
    fill: BLACK
tex = Centered:
    mesh: tex
    at: ORIGIN

play += Write:
    into&amp;: main
    value: tex
    time: 3
    sticky: 0
</code></pre>
<video controls>
    The gaussian integral
    <source src="/video/gaussian_integral.mp4" type="video/mp4"/>
</video>

<h2>5.5 Indication Animations</h2>
<p>Other animations that you might want to know of are indication methods. These add emphasis to a set of meshes. The standard library does not provide that many indication animations, but feel free to create your own! Heres an example of <a href="/docs/Highlight">Highlight</a>. </p>
<p><span class="lesson-remark">REMARK</span> Indication methods handle the trees for you, so you do not need to pass one in.</p>
<pre><code class="language-swift">let sq = Square:
    center: ORIGIN
    width: 1
    tag: {}
    stroke: RED
    fill: WHITE

play += Highlight:
    value: sq
    color: PURPLE
    time: 1
    sticky: 0
</code></pre>
<video controls>
    Highlight Example
    <source src="/video/highlight_example.mp4" type="video/mp4"/>
</video>

<h2>5.6 Modification of Meshes</h2>
<p><span class="lesson-important">IMPORTANT</span> Note that you should only modify trees through animations. Thus, the following code is wrong</p>
<pre><code class="language-swift">tree main
let sq = Square:
    center: ORIGIN
    width: 1
    tag: {}
    stroke: RED
    fill: WHITE

play += Show:
    into&amp;: main
    value: sq
    sticky: 0

/* we can't modify a tree variable directly */
/* instead, we should use animations */
main += Circle:
    center: ORIGIN
    radius: 1
    tag: {}
    color: default
</code></pre>
<p>Having a uniform source of updates leads to better code, albeit at the expense of more verbosity at times. </p>
<h2>5.7 Replace, Transfer, and Transformations</h2>
<p><span class="lesson-important">IMPORTANT</span> The next point is how to visibly alter meshes already on screen. This is where <a href="/docs/Replace">Replace</a> comes in. We are 'replacing' the tree with a new value.  Here's a simple example. Note that the transition happens instantly.</p>
<pre><code class="language-swift">tree main
let circle = Circle:
    center: ORIGIN
    radius: 1
    tag: {}
    stroke: BLACK

play += Show:
    into&amp;: main
    value: circle
    sticky: 0
/* wait can be called as a function */
play += Wait(1, 0)

var next = circle
next.radius = 2

play += Replace:
    dst&amp;: main
    target: next
    sticky: 0

play += Wait(1, 0)
</code></pre>
<video controls>
    Become example
    <source src="/video/become_example.mp4" type="video/mp4"/>
</video>

<p><span class="lesson-important">IMPORTANT</span> That's really rough, though. We can also use <a href="/docs/Transform">Transform</a> to do a more continous transformation. </p>
<pre><code class="language-swift">tree main
let circle = Circle:
    center: ORIGIN
    radius: 1
    tag: {}
    stroke: BLACK

play += Show:
    into&amp;: main
    value: circle
    sticky: 0
play += Wait(1, 0)

var next = circle
next.radius = 2

play += Transform:
    mesh&amp;: main
    target: next
    null_action: fade
    time: 1
    sticky: 0
play += Wait(1, 0)
</code></pre>
<video controls>
    Transform example
    <source src="/video/transform_example.mp4" type="video/mp4"/>
</video>

<p><span class="lesson-remark">REMARK</span> This is still pretty verbose and one of the things I want to change about Monocurl, but hopefully it's easy to follow.</p>
<p><span class="lesson-important">IMPORTANT</span> While <a href="/docs/Transfer">Transfer</a> and <a href="/docs/CopyTransfer">CopyTransfer</a> are generally only needed for more complex scenes it's good to know. It moves the variables from one tree to another tree (so nothing changes visually, but this is useful for conveying ownership). Example</p>
<pre><code class="language-swift">tree main
tree second
let circle = Circle:
    center: ORIGIN
    radius: 1
    tag: {}
    stroke: BLACK

play += Show:
    into&amp;: main
    value: circle
    sticky: 0

play += Transfer:
    into&amp;: second
    from&amp;: main
    sticky: 0

/* hiding main doesnt do anything since it's now empty */
play += Hide:
    from&amp;: main
    sticky: 0
</code></pre>
<h2>5.7 Scene Variable Animations</h2>
<p>Something else that's cool is that we can do some animations on scene variables, in particular, the <a href="/docs/%20camera">camera</a> and <a href="/docs/%20background">background</a>. In short, the camera dictates from what viewpoint the scene is rendered, and the background dictates the background color. Therefore, we can use Replace to possible switch the background color or change the view point in the middle of the scene (again, try it out!).</p>
<pre><code class="language-swift">play += Wait(1, 0)
play += Replace:
    dst&amp;: background
    target: BLUE
    sticky: 0
play += Wait(1, 0)
</code></pre>
<p>We'll see how to smoothly move the camera in lesson 7.</p>
<h2>5.8 Conclusion</h2>
<p><span class="lesson-meta">META</span> Honestly, we're pretty close to being able to do cool things. Theres really only two more things to understand to become proficient at Monocurl, the iterator-follower model, and more work on interpolation. </p><div id="next-lessons"><a href="/learn/4_Animation_Basics"> Previous Lesson </a><a href="/learn/6_Iterator_Follower_Paradigm"> Next Lesson </a></div></div><div class="sub-sections"><h1> Sections </h1><a id="label-0" href="#section-0" class="active">5.1 Visibility of Meshes</a><a id="label-1" href="#section-1" class="">5.2 Animation Syntax</a><a id="label-2" href="#section-2" class="">5.3 Show, Wait, and Hide</a><a id="label-3" href="#section-3" class="">5.4 More complex Show and Hide</a><a id="label-4" href="#section-4" class="">5.5 Indication Animations</a><a id="label-5" href="#section-5" class="">5.6 Modification of Meshes</a><a id="label-6" href="#section-6" class="">5.7 Replace, Transfer, and Transformations</a><a id="label-7" href="#section-7" class="">5.7 Scene Variable Animations</a><a id="label-8" href="#section-8" class="">5.8 Conclusion</a></div>
		</main>

		<footer>
			<div id="footer-legal"> 
				Copyright &copy Monocurl 2023. All rights reserved. 
			</div>

			<ul id="footer-links">
				<li> <a href="https://discord.com/invite/7g94JR3SAD">           Discord       </a> </li>
				<li> <a href="https://www.youtube.com/channel/monocurl">        YouTube       </a> </li>
				<li> <a href="https://github.com/monocurl/monocurl">			Source        </a> </li>
				<li> <a href="https://github.com/monocurl/monocurl.github.io">  Website Build </a> </li>
			</ul>
		</footer>
	</body>
</html>
    